import {DSL, DSLVariable, DSLReplacement} from './dsl';
import {CommentParser} from './parsers/comment.parser';
import {ReplacementParser} from "./parsers/replacement.parser";

export interface ParserOptions{
    exportComments?: boolean;
    commentBeginning?: string;
    commentEnding?: string;
    stringEscapeChar?: string;
    trueString?: string;
    falseString?: string;
}

export interface ScopedVariables{
    [key: string]: any;
}

const DEFAULT_PARSER_OPTIONS: ParserOptions = {
    exportComments: false,
    commentBeginning: '/*',
    commentEnding: '*/',
    stringEscapeChar: '\\',
    trueString: '1',
    falseString: '0'
};

export class Parser{
    private options: ParserOptions = <ParserOptions>{};
    constructor(options?: ParserOptions = {}){
        this.setOptions(options);
    }

    private setOptions(options: ParserOptions): Parser{
        for(var key of Object.keys(DEFAULT_PARSER_OPTIONS)){
            this.options[key] = options[key] || DEFAULT_PARSER_OPTIONS[key];
        }
        return this;
    }

    /**
     * Walk the DSL and generate final SQL output
     * @param dsls {DSL[]} - The DSL generated by the Lexer
     * @param variables {ScopedVariables}
     * @returns {string} - The final SQL output
     */
    public parse(dsls: DSL[], variables?: ScopedVariables): string{
        let output: string = '';
        let dsl: DSL;
        for(dsl of dsls){
            if(dsl.variable) variables = this.resolveVariable(dsl.variable, variables);
            //if(dsl.command) output += this.parseCommand(dsl);
            if(dsl.replacement) output += new ReplacementParser(this.options).parse(dsl.replacement, variables);
            if(dsl.comment && this.options.exportComments) output += new CommentParser(this.options).parse(dsl.comment);
            if(dsl.text) output += dsl.text;
        }
        return output;
    }

    /**
     * Resolve the known variables within the scope and return the modified collection
     *
     * @param dsl {DSLVariable}
     * @param scopedVariables {ScopedVariables}
     * @returns {ScopedVariables}
     */
    private resolveVariable(dsl: DSLVariable, scopedVariables: ScopedVariables): ScopedVariables{
        if(dsl.value[0] === `'` || dsl.value[0] === `"`){
            scopedVariables[dsl.key] = dsl.value.slice(1, dsl.value.length - 1);
        } else if(isNaN(<any>dsl.value)) {
            if(scopedVariables[dsl.value] == null) throw new Error(`SQiggLVariableResolutionError: Unable to find ${dsl.value} in the current scope`);
            scopedVariables[dsl.key] = scopedVariables[dsl.value];
        } else {
            scopedVariables[dsl.key] = parseFloat(dsl.value);
        }
        return scopedVariables;
    }
}