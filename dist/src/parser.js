var comment_parser_1 = require('./parsers/comment.parser');
var replacement_parser_1 = require("./parsers/replacement.parser");
var command_parser_1 = require("./parsers/command.parser");
exports.DEFAULT_PARSER_OPTIONS = {
    exportComments: false,
    commentBeginning: '/*',
    commentEnding: '*/',
    stringEscapeChar: '\\',
    trueString: '1',
    falseString: '0'
};
var Parser = (function () {
    function Parser(options) {
        if (options === void 0) { options = {}; }
        this.options = {};
        this.setOptions(options);
    }
    Parser.prototype.setOptions = function (options) {
        for (var _i = 0, _a = Object.keys(exports.DEFAULT_PARSER_OPTIONS); _i < _a.length; _i++) {
            var key = _a[_i];
            this.options[key] = options[key] || exports.DEFAULT_PARSER_OPTIONS[key];
        }
        return this;
    };
    /**
     * Walk the DSL and generate final SQL output
     *
     * @internal
     * @param dsl {DSL[]} - The DSL generated by the Lexer
     * @param variables {ScopedVariables}
     * @returns {string} - The final SQL output
     */
    Parser.prototype.parse = function (dsl, variables) {
        if (variables === void 0) { variables = {}; }
        var output = '', idx;
        for (idx = 0; idx < dsl.length; idx++) {
            if (dsl[idx].variable)
                variables = this.resolveVariable(dsl[idx].variable, variables);
            if (dsl[idx].command && !!dsl[idx].command.action.rule) {
                if ((!!dsl[idx].command.action.dependents && dsl[idx - 1].command.failed !== true))
                    continue;
                output += new command_parser_1.CommandParser(this.options).parse(dsl[idx], variables);
            }
            if (dsl[idx].replacement) {
                output += new replacement_parser_1.ReplacementParser(this.options).parse(dsl[idx].replacement, variables);
            }
            if (dsl[idx].comment && this.options.exportComments) {
                output += new comment_parser_1.CommentParser(this.options).parse(dsl[idx].comment);
            }
            if (dsl[idx].text)
                output += dsl[idx].text;
        }
        return output;
    };
    /**
     * Resolve the known variables within the scope and return the modified collection
     *
     * @param dsl {DSLVariable}
     * @param scopedVariables {ScopedVariables}
     * @returns {ScopedVariables}
     */
    Parser.prototype.resolveVariable = function (dsl, scopedVariables) {
        scopedVariables[dsl.key] = Parser.resolveValue(dsl.value, scopedVariables);
        return scopedVariables;
    };
    /**
     * Resolves a value as either a literal string, literal number,
     * or a variable value and then returns that value as a string.
     *
     * - If the value is an array, return it unchanged
     * - If the value starts with a quote, then it must be a string literal.
     *   Strip the quotes and return the literal value.
     * - If the value is a number, then it must be a literal number.
     *   Return the number unchanged.
     * - If a variable has the same name as the value, then resolve the
     *   value to the variable and return the value of the variable.
     * - Throw an error if none of the above.
     *
     * @internal
     * @param value {string | number | string[]} - The value to resolve.
     * @param variables {ScopedVariables} - The list of known variables for this scope.
     * @param suppressUndefinedVariableError {boolean} - Do not throw an error if a value cannot be resolved.
     * @returns {string} - The resolved value.
     */
    Parser.resolveValue = function (value, variables, suppressUndefinedVariableError) {
        if (suppressUndefinedVariableError === void 0) { suppressUndefinedVariableError = false; }
        if (Array.isArray(value))
            return value;
        if (value[0] === "'" || value[0] === "\"")
            return value.slice(1, value.length - 1);
        if (!isNaN(+value))
            return value.toString();
        if (!!variables && variables.hasOwnProperty(value))
            return variables[value];
        if (!suppressUndefinedVariableError)
            throw new Error("SQiggLParserError: " + value + " is not a defined variable in this scope");
    };
    return Parser;
})();
exports.Parser = Parser;
